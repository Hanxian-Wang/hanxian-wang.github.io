<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hanxian&#39;s Blog</title>
  
  <subtitle>A Simple Coder</subtitle>
  <link href="http://hanxian-wang.github.io/atom.xml" rel="self"/>
  
  <link href="http://hanxian-wang.github.io/"/>
  <updated>2025-06-05T06:23:17.328Z</updated>
  <id>http://hanxian-wang.github.io/</id>
  
  <author>
    <name>Harry Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Http面试八股文</title>
    <link href="http://hanxian-wang.github.io/2025/06/05/interview.data-3/"/>
    <id>http://hanxian-wang.github.io/2025/06/05/interview.data-3/</id>
    <published>2025-06-04T16:00:00.000Z</published>
    <updated>2025-06-05T06:23:17.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><ul><li><h2 id="说说Http的常用状态码有哪些？"><a href="#说说Http的常用状态码有哪些？" class="headerlink" title="说说Http的常用状态码有哪些？"></a>说说Http的常用状态码有哪些？</h2><ul><li>1xx表示信息</li><li>2xx表示成功</li><li>3xx表示重定向</li><li>4xx表示客户端错误</li><li>5xx表示服务端错误</li></ul><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</p><ul><li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li>101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级</li></ul><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p>代表请求已成功被服务器接收、理解、并接受。</p><ul><li>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</li><li>201（已创建）：请求成功并且服务器创建了新的资源</li><li>202（已创建）：服务器已经接收请求，但尚未处理</li><li>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</li><li>204（无内容）：服务器成功处理请求，但没有返回任何内容</li><li>205（重置内容）：服务器成功处理请求，但没有返回任何内容</li><li>206（部分内容）：服务器成功处理了部分请求</li></ul><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p><ul><li>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</li><li>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li><li>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</li><li>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</p><ul><li>400（错误请求）： 服务器不理解请求的语法</li><li>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403（禁止）： 服务器拒绝请求</li><li>404（未找到）： 服务器找不到请求的网页</li><li>405（方法禁用）： 禁用请求中指定的方法</li><li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li><li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li><li>408（请求超时）： 服务器等候请求时发生超时</li></ul><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生。</p><ul><li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li><li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li><li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li><li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">https://zh.wikipedia.org/wiki/HTTP状态码</a><br><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></p></li><li><h2 id="在浏览器中从输入URL到呈现页面发生了什么？"><a href="#在浏览器中从输入URL到呈现页面发生了什么？" class="headerlink" title="在浏览器中从输入URL到呈现页面发生了什么？"></a>在浏览器中从输入URL到呈现页面发生了什么？</h2><p><strong>直观解析</strong></p><pre><code class="highlight mermaid">graph LR解析URL--&gt;DNS查询--&gt;TCP连接--&gt;HTTP请求--&gt;响应请求--&gt;渲染页面</code></pre><ul><li>解析URL：判断输入的地址是否是合法的地址还是一个待搜索的关键词</li><li>DNS查询：对域名进行翻译，得到目标服务器的IP地址</li><li>TCP连接：得到目标服务器的IP地址后，经过三次TCP握手完成连接</li><li>HTTP请求：构建请求体，向目标服务器发送HTTP请求</li><li>响应请求：服务器构建响应体并返回，页面关闭后四次TCP挥手断开连接</li><li>渲染页面：根据不同的资源类型采用不同的解析方式</li></ul></li><li><h2 id="如何理解UDP和TCP？区别是什么？"><a href="#如何理解UDP和TCP？区别是什么？" class="headerlink" title="如何理解UDP和TCP？区别是什么？"></a>如何理解UDP和TCP？区别是什么？</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><blockquote><p>UDP(User Datagram Protocol)，即<strong>用户数据包协议</strong>，是一个面向<strong>数据报</strong>的通信协议。<br>形象理解，拿到一份UDP，直接统统转手发送出去这份。</p></blockquote><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><blockquote><p>TCP(Transmission Control Protocol)，即<strong>传输控制协议</strong>，是一个面向<strong>字节流</strong>的通信协议。<br>形象理解，发送方TCP会把数据放入一个类似蓄水池的缓冲区域，等到可以发送的时候再进行发送，并根据当前的网络状态来判断报文大小。</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3></li><li><h2 id="如何理解OSI七层模型？"><a href="#如何理解OSI七层模型？" class="headerlink" title="如何理解OSI七层模型？"></a>如何理解OSI七层模型？</h2><pre><code class="highlight mermaid">graph TD  应用层--&gt;表示层--&gt;会话层--&gt;传输层--&gt;网络层--&gt;数据链路层--&gt;物理层</code></pre></li><li><h2 id="如何理解TCP-IP协议？"><a href="#如何理解TCP-IP协议？" class="headerlink" title="如何理解TCP&#x2F;IP协议？"></a>如何理解TCP&#x2F;IP协议？</h2><blockquote><p>TCP&#x2F;IP协议并不只是含有TCP、IP协议，而是诸多协议的协议簇，以TCP、IP协议最具代表性而命名为TCP&#x2F;IP协议。<br>TCP&#x2F;IP协议从分析角度不同可以分为四层&#x2F;五层模型，五层模型一般常用于解析原理，实际运用为四层模型。</p></blockquote><pre><code class="highlight mermaid">graph TD  应用层--&gt;传输层--&gt;网络层--&gt;数据链路层</code></pre><p>与OSI七层模型有着显著联系：(<strong>上三下二中一一</strong>)</p><ul><li>TCP&#x2F;IP的应用层 –&gt; OSI的应用层、表示层、会话层</li><li>TCP&#x2F;IP的传输层、网络层 –&gt; OSI的传输层、网络层</li><li>TCP&#x2F;IP的数据链路层 –&gt; OSI的数据链路层、物理层</li></ul></li></ul><h1 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h1>]]></content>
    
    
    <summary type="html">关于HTTP的面试八股文</summary>
    
    
    
    <category term="笔记" scheme="http://hanxian-wang.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTTP" scheme="http://hanxian-wang.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>一些日常生活的琐事</title>
    <link href="http://hanxian-wang.github.io/2025/06/04/daily.share-1/"/>
    <id>http://hanxian-wang.github.io/2025/06/04/daily.share-1/</id>
    <published>2025-06-03T16:00:00.000Z</published>
    <updated>2025-06-03T17:15:52.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="就业"><a href="#就业" class="headerlink" title="就业"></a>就业</h1><p>临近大学生活的结尾（虽然现在还只是大三下，其本质上还是有一年的大学生活），小时候那个一直憧憬着长大的孩子开始有些…各种情绪混合起来的感觉：期待与害怕并存。<br>一方面是自己马上可以真的自己赚到钱，可以开始真正的有收入开始成为社会人，成年人的感觉，很是兴奋；另一方面是越发觉得自己的技术水平和现在社会普遍需要的能力有些不是非常符合的恐惧，时刻焦虑着自己是否在进入工作生活之后可以胜任好自己的那一班岗，是否可以很好地完成交付给我手中的任务，或者说是否可以真的找得到想要的工作呢？不过我还是希望可以找到自己向往的那份工作，不断努力提升自己吧。<br>另外看着专业大批大批目标是考研&#x2F;考公的，我这个直直奔着就业去的已然成为了特别的个例，大抵是眼下的这个就业市场确实比较惨淡吧。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>我测了很多次MBTI，或许是和绿老头(INFJ)很投缘，从始至终我的MBTI答案都只有它一位，但似乎与我”I”人特性有着一个很矛盾的点儿：我很讨厌真的是彻底独居的感觉。不得不说，每次假期因和家里（湖南）相距甚远，由于路程实在遥远确实不大想回去，但孤零零的自己呆在寝室没人和自己说话的日子稍微呆个三俩天，就感觉人开始从内部发臭，麻木。<br>从小到大的自己，确实还挺少过宿舍生活的，但不得不说有着几个平时聊得来玩得来、学得来的舍友一起过日子，还确实很有意思，感觉大部分的时间都是非常开心的。倘若现在突然让我开始独居的日子，或许我真的会很怀念这段回不去的时光。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>嗯，这就是一些在凌晨头脑比较混乱的时候的小随笔，或许言语有些逻辑混乱，但现阶段的自己确实也有些混乱。只希望眼下的找工作事宜可以有一个好的结果吧。</p>]]></content>
    
    
    <summary type="html">分享一点自己在生活里的想法</summary>
    
    
    
    <category term="日常分享" scheme="http://hanxian-wang.github.io/categories/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="生活" scheme="http://hanxian-wang.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>超图高校杯 命题开发组开发心得</title>
    <link href="http://hanxian-wang.github.io/2025/06/01/competition.gis-2/"/>
    <id>http://hanxian-wang.github.io/2025/06/01/competition.gis-2/</id>
    <published>2025-05-31T16:00:00.000Z</published>
    <updated>2025-06-01T05:57:52.411Z</updated>
    
    
    <summary type="html">关于参加2024年第22届超图高校GIS大赛(命题开发组)的一些心得体会</summary>
    
    
    
    <category term="经验分享" scheme="http://hanxian-wang.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="GIS" scheme="http://hanxian-wang.github.io/tags/GIS/"/>
    
    <category term="比赛" scheme="http://hanxian-wang.github.io/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>面试经验 - 网新恒天（前端开发实习生）</title>
    <link href="http://hanxian-wang.github.io/2025/05/30/interview.ex-1/"/>
    <id>http://hanxian-wang.github.io/2025/05/30/interview.ex-1/</id>
    <published>2025-05-29T16:00:00.000Z</published>
    <updated>2025-06-11T18:13:31.415Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><ul><li>自我介绍</li><li>简单询问一下项目和为什么选择前端</li><li>说说cookie、sessionStorage和localStorage的区别</li><li>怎么实现元素的拷贝？</li><li>谈谈浅拷贝和深拷贝，说说他们的区别</li><li>Javascript中常用的数组方法有哪些？</li><li>如何实现数组的去重？请自己写一个方法实现</li><li>如何实现元素的垂直居中和水平居中分布？</li><li>谈谈你对Vue的理解</li><li>闲聊</li><li>反问环节</li></ul></li><li><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><ul><li>为什么选择前端？</li><li>是否有意向在工作之余学习后端相关？</li><li>问项目，谈自己对全栈的一些理解</li><li>闲聊</li><li>反问环节</li></ul></li><li><h1 id="三面-oc"><a href="#三面-oc" class="headerlink" title="三面(oc)"></a>三面(oc)</h1><ul><li>到岗时间</li><li>确认薪资与福利等</li></ul></li></ul>]]></content>
    
    
    <summary type="html">关于面试网新恒天前端实习的一些经验分享</summary>
    
    
    
    <category term="经验分享" scheme="http://hanxian-wang.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Javascript" scheme="http://hanxian-wang.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript八股文</title>
    <link href="http://hanxian-wang.github.io/2025/05/28/interview.data-1/"/>
    <id>http://hanxian-wang.github.io/2025/05/28/interview.data-1/</id>
    <published>2025-05-27T16:00:00.000Z</published>
    <updated>2025-06-03T18:07:32.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><ul><li><h2 id="Javascript-中有什么数据类型？他们的区别的有什么？"><a href="#Javascript-中有什么数据类型？他们的区别的有什么？" class="headerlink" title="Javascript 中有什么数据类型？他们的区别的有什么？"></a>Javascript 中有什么数据类型？他们的区别的有什么？</h2><blockquote><p>数据类型：<strong>基本类型</strong>和<strong>引用类型</strong><br>基本类型：<strong>Number、String、Boolean、Null、Undefined、Symbol、BigInt(ES6 新增)</strong><br>引用类型：<strong>Object、Array、Function、Date</strong>等<br>区别：<br>声明变量时不同的内存地址分配：简单类型的值存放在栈中，在栈中存放的是对应的值;引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址<br>不同的类型数据导致赋值变量时的不同：简单类型赋值，是生成相同的值，两个对象对应不同的地址;复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</p></blockquote></li><li><h2 id="谈谈-Javascript-中的类型转换机制"><a href="#谈谈-Javascript-中的类型转换机制" class="headerlink" title="谈谈 Javascript 中的类型转换机制"></a>谈谈 Javascript 中的类型转换机制</h2><blockquote><p>类型：<strong>自动转换(隐式转换)<strong>和</strong>强制转换(显示转换)</strong></p></blockquote></li><li><h2 id="谈谈-Javascript-中的闭包，闭包有什么特点？"><a href="#谈谈-Javascript-中的闭包，闭包有什么特点？" class="headerlink" title="谈谈 Javascript 中的闭包，闭包有什么特点？"></a>谈谈 Javascript 中的闭包，闭包有什么特点？</h2><blockquote><p>定义：闭包就是一个函数和对其周围状态的引用的组合。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcOutside</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">funcInside</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//内部函数调用外部函数的变量，由于闭包特性是可以访问到的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特点: 创建私有变量;延长变量的生命周期</p></blockquote></li><li><h2 id="操作符’-’和’-’的区别"><a href="#操作符’-’和’-’的区别" class="headerlink" title="操作符’&#x3D;&#x3D;’和’&#x3D;&#x3D;&#x3D;’的区别"></a>操作符’&#x3D;&#x3D;’和’&#x3D;&#x3D;&#x3D;’的区别</h2><blockquote><p>&#x3D;&#x3D;操作符，即为等于操作符，在变量进行比较的时候会<strong>先进行隐式转换</strong>，然后再进行变量之间的比对。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 == str1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;&#x3D;操作符，即为全等操作符，在变量进行比较的时候会<strong>直接进行变量之间的比对</strong>，不会如等于操作符一样先进行隐式转换。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 === str1); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>浅拷贝：创建新的数据，这份新的数据拥有原始数据属性值的一份精准拷贝。如果是基本类型拷贝，拷贝的是<strong>属性的值</strong>;如果是引用类型拷贝，拷贝的是<strong>内存地址</strong>。即拷贝的数据和原始数据共享同一内存地址。</p></blockquote><p><strong>实现一个浅拷贝</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = &#123;&#125;; <span class="comment">// const不可以修改内存地址，但可以修改属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      newObj[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Javascript 中存在浅拷贝现象的方法还有:</strong></p><ul><li>Object.assign()</li><li>Array.prototype.slice(), Array.prototype.concat()</li><li>…</li></ul><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>深拷贝：开辟一个新的栈，两个对象属性完全相同，但是<strong>对应两个不同的地址</strong>，修改一个对象的属性，不会改变另一个对象的属性。</p></blockquote><p><strong>实现一个深拷贝</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Javascript 中存在深拷贝现象的方法还有:</strong></p><ul><li>_.cloneDeep()</li><li>jQuery.extend()</li><li>JSON.stringify()</li><li>…</li></ul></li><li><h2 id="什么是作用域链？"><a href="#什么是作用域链？" class="headerlink" title="什么是作用域链？"></a>什么是作用域链？</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h3><blockquote><p>作用域，即为变量和函数生效的区域或集合。<br>作用域一般分为：<strong>全局作用域、函数作用域和块级作用域(ES6+)</strong></p></blockquote><p><strong>全局作用域</strong></p><blockquote><p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p><strong>函数作用域</strong></p><blockquote><p>函数作用域另称局部作用域，当一个变量是声明在函数内部时，它只能被函数内部进行访问，不能由函数外部进行访问。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1); <span class="comment">//输出 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1); <span class="comment">//Undefined</span></span><br></pre></td></tr></table></figure><p><strong>块级作用域</strong></p><blockquote><p>块级作用域是由 ES6 中新增的 let 和 const 关键字，在一对大括号中声明的 let 和 const 关键字存在于块级作用域中，在大括号之外不可访问。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> num2 = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2); <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2); <span class="comment">// Undefined, Undefined</span></span><br></pre></td></tr></table></figure><p><strong>词法作用域</strong></p><blockquote><p>词法作用域就是静态作用域，一个变量一旦被创建就会被定义好其静态作用域，而不是代码执行过程中定义好的。</p></blockquote><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a><strong>作用域链</strong></h3><blockquote><p>作用域链就是当 Javascript 去使用一个变量的时候，会从当前作用域下开始寻找，如果没有找到则会依次向上寻找，直至最高层全局作用域。如果没有找到，则会隐式创建变量或者报错。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num3 = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num3); <span class="comment">// 当前作用域</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num2); <span class="comment">// 往上找到num2，闭包</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num1); <span class="comment">// 在全局作用域找到num1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num3); <span class="comment">// 不可往下找，报错Undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure></li><li><h2 id="谈谈-Javascript-中的原型和原型链"><a href="#谈谈-Javascript-中的原型和原型链" class="headerlink" title="谈谈 Javascript 中的原型和原型链"></a>谈谈 Javascript 中的原型和原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote><p>Javascript 是一种基于原型的语言，每个对象都会有对应的原型。对象的属性和方法定义在 Object 的构造器函数的 prototype 属性上。</p></blockquote><p><strong>原型对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">constructor</span>: ƒ <span class="string">&#x27;YourFunction&#x27;</span>(),</span><br><span class="line">  <span class="attr">__proto__</span>: &#123;</span><br><span class="line">      <span class="attr">constructor</span>: ƒ <span class="title class_">Object</span>(),</span><br><span class="line">      <span class="attr">hasOwnProperty</span>: ƒ <span class="title function_">hasOwnProperty</span>(),</span><br><span class="line">      <span class="attr">isPrototypeOf</span>: ƒ <span class="title function_">isPrototypeOf</span>(),</span><br><span class="line">      <span class="attr">propertyIsEnumerable</span>: ƒ <span class="title function_">propertyIsEnumerable</span>(),</span><br><span class="line">      <span class="attr">toLocaleString</span>: ƒ <span class="title function_">toLocaleString</span>(),</span><br><span class="line">      <span class="attr">toString</span>: ƒ <span class="title function_">toString</span>(),</span><br><span class="line">      <span class="attr">valueOf</span>: ƒ <span class="title function_">valueOf</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>一切对象都继承自 Object 对象，Object 对象直接继承根源对象 Null。</li><li>一切函数对象都继承自 Function 对象。</li><li>Object 直接继承自 Function 对象。</li><li>Function 的<em>proto</em>指向自己的原型对象，最终指向 Object 对象。</li></ul></li><li><h2 id="在-Javascript-中如何实现继承？"><a href="#在-Javascript-中如何实现继承？" class="headerlink" title="在 Javascript 中如何实现继承？"></a>在 Javascript 中如何实现继承？</h2><blockquote><p>常见的继承方式：<strong>extends 关键字(ES6+)、原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承</strong>。</p></blockquote><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote><p>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;parent1&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&quot;child2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child1</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child</span>());</span><br></pre></td></tr></table></figure><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><blockquote><p>父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;parent1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title class_">Parent1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child) <span class="comment">// 正常运行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chile.<span class="title function_">getName</span>()) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><blockquote><p>组合继承则将前两种方式继承起来。</p></blockquote><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><blockquote><p>借助Object.create方法实现普通对象的继承。</p></blockquote><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><blockquote><p>寄生式继承在原型式继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法。</p></blockquote><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><blockquote><p>借助解决普通对象的继承问题的Object.create 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式。</p></blockquote></li><li><h2 id="谈谈你对this对象的理解"><a href="#谈谈你对this对象的理解" class="headerlink" title="谈谈你对this对象的理解"></a>谈谈你对this对象的理解</h2><h3 id="this关键字是什么"><a href="#this关键字是什么" class="headerlink" title="this关键字是什么"></a>this关键字是什么</h3><blockquote><p>this关键字是函数运行的时候自动生成的一个内部对象，只能在函数内部使用，this总指向调用他的对象。并且，this关键字<strong>一旦确定，不可更改。</strong>  </p></blockquote><h3 id="绑定规则和优先级"><a href="#绑定规则和优先级" class="headerlink" title="绑定规则和优先级"></a>绑定规则和优先级</h3><ul><li>默认绑定</li><li>隐式绑定</li><li>显示绑定</li><li>new绑定<blockquote><p>new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定</p></blockquote></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><blockquote><p>与传统函数不同，箭头函数中的this关键字<strong>指向该箭头函数被定义的对象</strong>。</p></blockquote></li><li><h2 id="Javascript中执行上下文和执行栈是什么？"><a href="#Javascript中执行上下文和执行栈是什么？" class="headerlink" title="Javascript中执行上下文和执行栈是什么？"></a>Javascript中执行上下文和执行栈是什么？</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote><p>执行上下文是一种对Javascript的代码执行环境的一种抽象概念，即只要有Javascript代码则会有执行上下文。  </p></blockquote><p><strong>执行上下文的类别</strong></p><ul><li>全局执行上下文：变量在全局内，只有一个全局执行上下文，浏览器的全局对象是window。</li><li>函数执行上下文：可以有无数个，当函数被调用执行的时候，就会创建一个对应的函数执行上下文。</li><li>Eval函数执行上下文：运行在eval函数中的代码，使用频率很低。</li></ul><p>执行上下文的生命周期：</p><pre><code class="highlight mermaid">graph LR  创建阶段--&gt;执行阶段--&gt;回收阶段</code></pre><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><blockquote><p>执行栈又称调用栈，它拥有<strong>后进先出</strong>的结构，用于存储所有的执行上下文。<br>当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中，后续每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中，引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文。</p></blockquote></li><li><h2 id="谈谈typeof和instanceof的区别"><a href="#谈谈typeof和instanceof的区别" class="headerlink" title="谈谈typeof和instanceof的区别"></a>谈谈typeof和instanceof的区别</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>typeof返回的是一个变量的基本类型。</li><li>typeof可以返回除(Null)外的基本类型，除(Function)外的引用类型。</li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul><li>instanceof返回的是布尔值。</li><li>instanceof可以准确判断变量的引用类型，但不可以判断变量的基本类型。</li></ul></li><li><h2 id="说说new操作符具体做了什么？"><a href="#说说new操作符具体做了什么？" class="headerlink" title="说说new操作符具体做了什么？"></a>说说new操作符具体做了什么？</h2><ul><li>创建一个新的对象。</li><li>把新的对象的_proto_指向原函数的构造函数。</li><li>将构造函数内的this指向到新对象上。</li><li>检查构造函数返回值。</li></ul><p>new操作符具体流程：</p><pre><code class="highlight mermaid">graph LR  新建对象--&gt;_proto_绑定--&gt;this绑定--&gt;检查返回值</code></pre></li><li><h2 id="说说Javascript中的事件模型"><a href="#说说Javascript中的事件模型" class="headerlink" title="说说Javascript中的事件模型"></a>说说Javascript中的事件模型</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><blockquote><p>在HTML文档或浏览器中发生的一系列交互操作，就称为事件。</p></blockquote><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><blockquote><p>由于DOM是一个树结构，因此在出现父子节点绑定事件，触发子节点的时候会引起顺序问题，由此有事件流之概念。  </p></blockquote><p>事件流有三个阶段：</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>事件模型分为三种：</p><ul><li>原始事件模型</li><li>标准事件模型</li><li>IE事件模型</li></ul><p><strong>原始事件模型</strong></p><blockquote><p>没有事件冒泡阶段</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;func()&quot;</span>&gt; <span class="comment">//此处的onclick绑定事件就是原始事件绑定</span></span><br></pre></td></tr></table></figure><p><strong>标准事件模型</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line"><span class="title function_">addEventListener</span>(eventType, handler, useCapture)</span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="title function_">removeEventListener</span>(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p><strong>IE事件模型</strong></p><blockquote><p>没有事件冒泡阶段</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line"><span class="title function_">attachEvent</span>(eventType, handler)</span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="title function_">detachEvent</span>(eventType, handler)</span><br></pre></td></tr></table></figure></li><li><h2 id="谈谈什么是事件代理？"><a href="#谈谈什么是事件代理？" class="headerlink" title="谈谈什么是事件代理？"></a>谈谈什么是事件代理？</h2><blockquote><p>事件代理就是指<strong>把事件委托在目标元素的外层元素上，当触发目标元素时，通过事件冒泡机制触发到它的外层绑定元素上，执行相应函数。</strong>  </p></blockquote><p><strong>整体有两大优点</strong>：</p><ul><li>减少内存使用。</li><li>动态绑定，避开重复工作。</li></ul></li><li><h2 id="ajax原理是什么？"><a href="#ajax原理是什么？" class="headerlink" title="ajax原理是什么？"></a>ajax原理是什么？</h2><ul><li>创建核心XmlHttpRequest(Xhr)对象。</li><li>通过Xhr对象的open方法，与服务器连接。</li><li>构造请求所需要的数据内容，通过Xhr的send方法发送给服务端。</li><li>通过Xhr对象提供的onreadystagechange监听服务端变化。</li><li>接收并处理服务端返回的结果数据。</li><li>将处理结果用javascript操作DOM实现更新。</li></ul><pre><code class="highlight mermaid">graph LR    创建Xhr对象--&gt;|open方法|连接服务器--&gt;|send方法|发送请求--&gt;|onreadystagechange|监听变化--&gt;接收并处理结果--&gt;|操作DOM|更新页面</code></pre></li><li><h2 id="谈谈bind-apply和call三者的区别"><a href="#谈谈bind-apply和call三者的区别" class="headerlink" title="谈谈bind,apply和call三者的区别"></a>谈谈bind,apply和call三者的区别</h2><p><strong>共同点</strong></p><ul><li>目的都是修改this关键字的指向。</li><li>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。  </li><li></li></ul><p><strong>不同点</strong></p><ul><li>apply和call是单次传参，bind可多次传参。</li><li>apply的参数为数组，call的参数为参数列表.</li><li>bind返回绑定this参数后的函数，apply和call立即执行函数。</li></ul></li><li><h2 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h2><blockquote><p>同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环。  </p></blockquote><p><strong>任务分为</strong>：</p><ul><li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行。</li><li>异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等<ul><li>微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</li><li>宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。</li></ul></li></ul></li><li><h2 id="说说Javascript中常见的内存泄露情况"><a href="#说说Javascript中常见的内存泄露情况" class="headerlink" title="说说Javascript中常见的内存泄露情况"></a>说说Javascript中常见的内存泄露情况</h2><ul><li>意外的全局变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  wrong = <span class="number">1</span> <span class="comment">// 变量没有在任何作用域有定义，会在全局作用域中隐式定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">wrong</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func2</span>() <span class="comment">//此时函数内this指向window，又会隐式生成一个全局变量</span></span><br></pre></td></tr></table></figure></li><li>闭包的私有变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcOutside</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;......&#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">funcInside</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// 没有清理对私有变量的引用</span></span><br><span class="line">    obj = <span class="literal">null</span> <span class="comment">// 需要这样正确清理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>未正确释放的DOM引用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refA = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;refA&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(refA)</span><br><span class="line"><span class="comment">//需要清理</span></span><br><span class="line">refA = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li><li>计时器中的引用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = <span class="title function_">getData</span>();</span><br><span class="line"><span class="title function_">setInteral</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;node&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">    <span class="comment">//外部引用</span></span><br><span class="line">    node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><h2 id="谈谈Javascript中的几种本地存储"><a href="#谈谈Javascript中的几种本地存储" class="headerlink" title="谈谈Javascript中的几种本地存储"></a>谈谈Javascript中的几种本地存储</h2><ul><li>cookie</li><li>sessionStorage</li><li>localStorage</li></ul><p><strong>不同点</strong></p><ul><li>存储大小：cookie只能存储最多<strong>4K</strong>大小的文本数据，而后两者可以存储<strong>5MB以上</strong>的数据。</li><li>生命周期：cookie的生命周期取决于<strong>设置的过期时间</strong>，sessionStorage是在<strong>当前窗口关闭的时候会自动删除</strong>，localStorage<strong>存储持久数据</strong>，关闭浏览器不会丢失数据。</li><li>交互方法：cookie的数据会自动传输给服务器，服务器也可以写cookie给客户端。localStorage和sessionStorage只能在本地存储。</li></ul></li><li><h2 id="谈谈Javascript中数字精度丢失的问题"><a href="#谈谈Javascript中数字精度丢失的问题" class="headerlink" title="谈谈Javascript中数字精度丢失的问题"></a>谈谈Javascript中数字精度丢失的问题</h2><blockquote><p>简单的说，就是十进制数字需要先转为二进制数，然后再进行计算后转回十进制数得到结果。其中，进制的转换会由于<strong>位数限制、某些数转二进制出现无限循环</strong>造成数值转换后会出现偏差，导致结果不符合直觉。</p></blockquote></li><li><h2 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><blockquote><p>防抖就是指在n秒后再执行事件，如果在n秒内重复触发，则重新计时。</p></blockquote><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><blockquote><p>节流就是指在n秒内只执行一次事件，如果在n秒内重复触发，只有一次生效。</p></blockquote></li></ul><h1 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h1>]]></content>
    
    
    <summary type="html">关于Javascipt的面试八股文</summary>
    
    
    
    <category term="笔记" scheme="http://hanxian-wang.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Javascript" scheme="http://hanxian-wang.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>CSS八股文</title>
    <link href="http://hanxian-wang.github.io/2025/05/28/interview.data-2/"/>
    <id>http://hanxian-wang.github.io/2025/05/28/interview.data-2/</id>
    <published>2025-05-27T16:00:00.000Z</published>
    <updated>2025-06-01T06:24:12.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><ul><li><h2 id="说说你对盒子模型的理解"><a href="#说说你对盒子模型的理解" class="headerlink" title="说说你对盒子模型的理解"></a>说说你对盒子模型的理解</h2><p><strong>盒子模型的图例</strong><br><img src="https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/Styling_basics/Box_model/box-model.png" alt="盒子模型" title="盒子模型图例"><br>盒子模型主要分为两种：</p><ul><li>标准盒子模型：content的width&#x2F;height不包含padding&#x2F;border</li><li>怪异盒子模型：content的width&#x2F;height包含padding&#x2F;border</li></ul></li><li><h2 id="CSS选择器有哪些？优先级如何？"><a href="#CSS选择器有哪些？优先级如何？" class="headerlink" title="CSS选择器有哪些？优先级如何？"></a>CSS选择器有哪些？优先级如何？</h2><ul><li><strong>常用的选择器有：</strong><ul><li>ID选择器 #a</li><li>类选择器 .a</li><li>标签选择器 div</li><li>子选择器 #a b</li><li>后代选择器 a&gt;a_1</li><li>相邻同胞选择器 .a+.b</li><li>群组选择器 div,p</li></ul></li><li><strong>不常用的选择器有：</strong><ul><li>伪类选择器</li><li>伪元素选择器</li><li>属性选择器</li><li>层次选择器</li></ul></li><li><strong>优先级:</strong> 内联&gt;ID&gt;类&gt;…</li></ul></li><li><h2 id="谈谈你对Flex布局的理解"><a href="#谈谈你对Flex布局的理解" class="headerlink" title="谈谈你对Flex布局的理解"></a>谈谈你对Flex布局的理解</h2><blockquote><p>Flex布局，即弹性盒子布局，容器内部是有一条主轴和与之形成直角的交叉轴构成，容器内元素默认沿主轴方向排列，其方向由flex-direction决定。  </p></blockquote><p><strong>Flex布局图例</strong><br><img src="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox/basics1.svg" alt="flex布局" title="flex布局图例"><br><img src="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox/basics3.svg" alt="flex布局" title="flex布局图例"></p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul></li><li><h2 id="谈谈你对BFC的理解"><a href="#谈谈你对BFC的理解" class="headerlink" title="谈谈你对BFC的理解"></a>谈谈你对BFC的理解</h2><p> BFC（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则：</p><ul><li>内部的盒子会在垂直方向上一个接一个的放置</li><li>对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。</li><li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 <blockquote><p>BFC目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素。</p></blockquote></li></ul><p> <strong>触发条件</strong></p><ul><li>根元素，即HTML元素</li><li>浮动元素：float值为left、right</li><li>overflow值不为 visible，为 auto、scroll、hidden</li><li>display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li><li>position的值为absolute或fixed</li></ul></li></ul>]]></content>
    
    
    <summary type="html">关于CSS的面试八股文</summary>
    
    
    
    <category term="笔记" scheme="http://hanxian-wang.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CSS" scheme="http://hanxian-wang.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>测绘程序设计大赛心得</title>
    <link href="http://hanxian-wang.github.io/2024/05/01/competition.gis-1/"/>
    <id>http://hanxian-wang.github.io/2024/05/01/competition.gis-1/</id>
    <published>2024-04-30T16:00:00.000Z</published>
    <updated>2025-06-05T05:52:09.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a>经验分享</h1><ul><li><h2 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h2><blockquote><p>测绘程序设计比赛由于是比较新的比赛，比赛难度实际不大，主要就是考察<strong>文件的读写、把书面公式转为逻辑代码</strong>的能力。  </p></blockquote><p>需要把几个部分分开，这样很好分清自己的代码逻辑</p><ul><li>算法类，专门实现需要翻译的算法部分(Algo.cs)</li><li>实体类，根据题目需求创建对应的实体，并合理管理其方法和属性(Entity.cs)</li><li>工具类，存放如文件读写、数学函数、日期函数等辅助方法(Utils.cs)</li><li>窗体类，主页面部分，实现页面交互功能(Form.cs)</li></ul></li><li><h2 id="赛题分析"><a href="#赛题分析" class="headerlink" title="赛题分析"></a>赛题分析</h2><blockquote><p>2024年的测绘程序设计比赛的题目是<code>空间数据探索性分析</code>，考察<strong>计算莫兰指数</strong>。</p></blockquote></li><li><h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 莫兰指数计算</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;data&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MoranIndex</span>(<span class="params">List&lt;Point&gt; data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> N = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//研究区域犯罪事件的平均值</span></span><br><span class="line">    meanX_Moran = (<span class="built_in">double</span>)data.Count / N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> over = <span class="number">0</span>, under = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        under += Math.Pow(counts[i] - meanX_Moran, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            S0 += weightMartix[i, j];</span><br><span class="line">            over += weightMartix[i, j] * (counts[i] - meanX_Moran) * (counts[j] - meanX_Moran);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    I = (N / S0) * (over / under);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 局部莫兰指数计算</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MoranIndex_</span>(<span class="params"><span class="built_in">int</span> code</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//局部莫兰指数的计算</span></span><br><span class="line">    <span class="built_in">int</span> N = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//传入区域号为code 即为i = code-1</span></span><br><span class="line">    <span class="built_in">double</span> over2 = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//j!=i</span></span><br><span class="line">        <span class="keyword">if</span> (j == (code - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            over2 += Math.Pow(counts[j] - meanX_Moran, <span class="number">2</span>);</span><br><span class="line">            right += weightMartix[code - <span class="number">1</span>, j] * (counts[j] - meanX_Moran);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Si = over2 / (N - <span class="number">1</span>);</span><br><span class="line">    Ii[code - <span class="number">1</span>] = right * (counts[code - <span class="number">1</span>] - meanX_Moran) / Si / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 计算局部莫兰指数的Z得分</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Ii&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CalculateZScore</span>(<span class="params"><span class="built_in">double</span>[] I</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> N = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">double</span> over = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">double</span> over2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> I)</span><br><span class="line">    &#123;</span><br><span class="line">        over += i;</span><br><span class="line">    &#125;</span><br><span class="line">    u = over / N;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> I)</span><br><span class="line">    &#123;</span><br><span class="line">        over2 += Math.Pow(i - u, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    o = Math.Sqrt(over2 / (N - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Zi[i] = (I[i] - u) / o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">关于参加测绘程序设计大赛(C#)的心得</summary>
    
    
    
    <category term="经验分享" scheme="http://hanxian-wang.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="GIS" scheme="http://hanxian-wang.github.io/tags/GIS/"/>
    
    <category term="比赛" scheme="http://hanxian-wang.github.io/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
</feed>
