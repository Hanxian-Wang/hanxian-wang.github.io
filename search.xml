<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一些日常生活的琐事</title>
      <link href="/2025/06/04/daily.share-1/"/>
      <url>/2025/06/04/daily.share-1/</url>
      
        <content type="html"><![CDATA[<h1 id="就业"><a href="#就业" class="headerlink" title="就业"></a>就业</h1><p>临近大学生活的结尾（虽然现在还只是大三下，其本质上还是有一年的大学生活），小时候那个一直憧憬着长大的孩子开始有些…各种情绪混合起来的感觉：期待与害怕并存。<br>一方面是自己马上可以真的自己赚到钱，可以开始真正的有收入开始成为社会人，成年人的感觉，很是兴奋；另一方面是越发觉得自己的技术水平和现在社会普遍需要的能力有些不是非常符合的恐惧，时刻焦虑着自己是否在进入工作生活之后可以胜任好自己的那一班岗，是否可以很好地完成交付给我手中的任务，或者说是否可以真的找得到想要的工作呢？不过我还是希望可以找到自己向往的那份工作，不断努力提升自己吧。<br>另外看着专业大批大批目标是考研&#x2F;考公的，我这个直直奔着就业去的已然成为了特别的个例，大抵是眼下的这个就业市场确实比较惨淡吧。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>我测了很多次MBTI，或许是和绿老头(INFJ)很投缘，从始至终我的MBTI答案都只有它一位，但似乎与我”I”人特性有着一个很矛盾的点儿：我很讨厌真的是彻底独居的感觉。不得不说，每次假期因和家里（湖南）相距甚远，由于路程实在遥远确实不大想回去，但孤零零的自己呆在寝室没人和自己说话的日子稍微呆个三俩天，就感觉人开始从内部发臭，麻木。<br>从小到大的自己，确实还挺少过宿舍生活的，但不得不说有着几个平时聊得来玩得来、学得来的舍友一起过日子，还确实很有意思，感觉大部分的时间都是非常开心的。倘若现在突然让我开始独居的日子，或许我真的会很怀念这段回不去的时光。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>嗯，这就是一些在凌晨头脑比较混乱的时候的小随笔，或许言语有些逻辑混乱，但现阶段的自己确实也有些混乱。只希望眼下的找工作事宜可以有一个好的结果吧。</p>]]></content>
      
      
      <categories>
          
          <category> 日常分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超图高校杯 命题开发组开发心得</title>
      <link href="/2025/06/01/competition.gis-2/"/>
      <url>/2025/06/01/competition.gis-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIS </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript八股文</title>
      <link href="/2025/05/28/interview.data-1/"/>
      <url>/2025/05/28/interview.data-1/</url>
      
        <content type="html"><![CDATA[<h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><ul><li><h2 id="Javascript-中有什么数据类型？他们的区别的有什么？"><a href="#Javascript-中有什么数据类型？他们的区别的有什么？" class="headerlink" title="Javascript 中有什么数据类型？他们的区别的有什么？"></a>Javascript 中有什么数据类型？他们的区别的有什么？</h2><blockquote><p>数据类型：<strong>基本类型</strong>和<strong>引用类型</strong><br>基本类型：<strong>Number、String、Boolean、Null、Undefined、Symbol、BigInt(ES6 新增)</strong><br>引用类型：<strong>Object、Array、Function、Date</strong>等<br>区别：<br>声明变量时不同的内存地址分配：简单类型的值存放在栈中，在栈中存放的是对应的值;引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址<br>不同的类型数据导致赋值变量时的不同：简单类型赋值，是生成相同的值，两个对象对应不同的地址;复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</p></blockquote></li><li><h2 id="谈谈-Javascript-中的类型转换机制"><a href="#谈谈-Javascript-中的类型转换机制" class="headerlink" title="谈谈 Javascript 中的类型转换机制"></a>谈谈 Javascript 中的类型转换机制</h2><blockquote><p>类型：<strong>自动转换(隐式转换)<strong>和</strong>强制转换(显示转换)</strong></p></blockquote></li><li><h2 id="谈谈-Javascript-中的闭包，闭包有什么特点？"><a href="#谈谈-Javascript-中的闭包，闭包有什么特点？" class="headerlink" title="谈谈 Javascript 中的闭包，闭包有什么特点？"></a>谈谈 Javascript 中的闭包，闭包有什么特点？</h2><blockquote><p>定义：闭包就是一个函数和对其周围状态的引用的组合。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcOutside</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">funcInside</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//内部函数调用外部函数的变量，由于闭包特性是可以访问到的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特点: 创建私有变量;延长变量的生命周期</p></blockquote></li><li><h2 id="操作符’-’和’-’的区别"><a href="#操作符’-’和’-’的区别" class="headerlink" title="操作符’&#x3D;&#x3D;’和’&#x3D;&#x3D;&#x3D;’的区别"></a>操作符’&#x3D;&#x3D;’和’&#x3D;&#x3D;&#x3D;’的区别</h2><blockquote><p>&#x3D;&#x3D;操作符，即为等于操作符，在变量进行比较的时候会<strong>先进行隐式转换</strong>，然后再进行变量之间的比对。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 == str1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;&#x3D;操作符，即为全等操作符，在变量进行比较的时候会<strong>直接进行变量之间的比对</strong>，不会如等于操作符一样先进行隐式转换。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1 === str1); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>浅拷贝：创建新的数据，这份新的数据拥有原始数据属性值的一份精准拷贝。如果是基本类型拷贝，拷贝的是<strong>属性的值</strong>;如果是引用类型拷贝，拷贝的是<strong>内存地址</strong>。即拷贝的数据和原始数据共享同一内存地址。</p></blockquote><p><strong>实现一个浅拷贝</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = &#123;&#125;; <span class="comment">// const不可以修改内存地址，但可以修改属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      newObj[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Javascript 中存在浅拷贝现象的方法还有:</strong></p><ul><li>Object.assign()</li><li>Array.prototype.slice(), Array.prototype.concat()</li><li>…</li></ul><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>深拷贝：开辟一个新的栈，两个对象属性完全相同，但是<strong>对应两个不同的地址</strong>，修改一个对象的属性，不会改变另一个对象的属性。</p></blockquote><p><strong>实现一个深拷贝</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Javascript 中存在深拷贝现象的方法还有:</strong></p><ul><li>_.cloneDeep()</li><li>jQuery.extend()</li><li>JSON.stringify()</li><li>…</li></ul></li><li><h2 id="什么是作用域链？"><a href="#什么是作用域链？" class="headerlink" title="什么是作用域链？"></a>什么是作用域链？</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h3><blockquote><p>作用域，即为变量和函数生效的区域或集合。<br>作用域一般分为：<strong>全局作用域、函数作用域和块级作用域(ES6+)</strong></p></blockquote><p><strong>全局作用域</strong></p><blockquote><p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p><strong>函数作用域</strong></p><blockquote><p>函数作用域另称局部作用域，当一个变量是声明在函数内部时，它只能被函数内部进行访问，不能由函数外部进行访问。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1); <span class="comment">//输出 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1); <span class="comment">//Undefined</span></span><br></pre></td></tr></table></figure><p><strong>块级作用域</strong></p><blockquote><p>块级作用域是由 ES6 中新增的 let 和 const 关键字，在一对大括号中声明的 let 和 const 关键字存在于块级作用域中，在大括号之外不可访问。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> num2 = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2); <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2); <span class="comment">// Undefined, Undefined</span></span><br></pre></td></tr></table></figure><p><strong>词法作用域</strong></p><blockquote><p>词法作用域就是静态作用域，一个变量一旦被创建就会被定义好其静态作用域，而不是代码执行过程中定义好的。</p></blockquote><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a><strong>作用域链</strong></h3><blockquote><p>作用域链就是当 Javascript 去使用一个变量的时候，会从当前作用域下开始寻找，如果没有找到则会依次向上寻找，直至最高层全局作用域。如果没有找到，则会隐式创建变量或者报错。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num3 = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num3); <span class="comment">// 当前作用域</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num2); <span class="comment">// 往上找到num2，闭包</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num1); <span class="comment">// 在全局作用域找到num1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num3); <span class="comment">// 不可往下找，报错Undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure></li><li><h2 id="谈谈-Javascript-中的原型和原型链"><a href="#谈谈-Javascript-中的原型和原型链" class="headerlink" title="谈谈 Javascript 中的原型和原型链"></a>谈谈 Javascript 中的原型和原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote><p>Javascript 是一种基于原型的语言，每个对象都会有对应的原型。对象的属性和方法定义在 Object 的构造器函数的 prototype 属性上。</p></blockquote><p><strong>原型对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">constructor</span>: ƒ <span class="string">&#x27;YourFunction&#x27;</span>(),</span><br><span class="line">  <span class="attr">__proto__</span>: &#123;</span><br><span class="line">      <span class="attr">constructor</span>: ƒ <span class="title class_">Object</span>(),</span><br><span class="line">      <span class="attr">hasOwnProperty</span>: ƒ <span class="title function_">hasOwnProperty</span>(),</span><br><span class="line">      <span class="attr">isPrototypeOf</span>: ƒ <span class="title function_">isPrototypeOf</span>(),</span><br><span class="line">      <span class="attr">propertyIsEnumerable</span>: ƒ <span class="title function_">propertyIsEnumerable</span>(),</span><br><span class="line">      <span class="attr">toLocaleString</span>: ƒ <span class="title function_">toLocaleString</span>(),</span><br><span class="line">      <span class="attr">toString</span>: ƒ <span class="title function_">toString</span>(),</span><br><span class="line">      <span class="attr">valueOf</span>: ƒ <span class="title function_">valueOf</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>一切对象都继承自 Object 对象，Object 对象直接继承根源对象 Null。</li><li>一切函数对象都继承自 Function 对象。</li><li>Object 直接继承自 Function 对象。</li><li>Function 的<em>proto</em>指向自己的原型对象，最终指向 Object 对象。</li></ul></li><li><h2 id="在-Javascript-中如何实现继承？"><a href="#在-Javascript-中如何实现继承？" class="headerlink" title="在 Javascript 中如何实现继承？"></a>在 Javascript 中如何实现继承？</h2><blockquote><p>常见的继承方式：<strong>extends 关键字(ES6+)、原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承</strong>。</p></blockquote><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote><p>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;parent1&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&quot;child2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child1</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child</span>());</span><br></pre></td></tr></table></figure><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><blockquote><p>父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;parent1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title class_">Parent1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child) <span class="comment">// 正常运行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(chile.<span class="title function_">getName</span>()) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><blockquote><p>组合继承则将前两种方式继承起来。</p></blockquote><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><blockquote><p>借助Object.create方法实现普通对象的继承。</p></blockquote><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><blockquote><p>寄生式继承在原型式继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法。</p></blockquote><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><blockquote><p>借助解决普通对象的继承问题的Object.create 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式。</p></blockquote></li><li><h2 id="谈谈你对this对象的理解"><a href="#谈谈你对this对象的理解" class="headerlink" title="谈谈你对this对象的理解"></a>谈谈你对this对象的理解</h2><h3 id="this关键字是什么"><a href="#this关键字是什么" class="headerlink" title="this关键字是什么"></a>this关键字是什么</h3><blockquote><p>this关键字是函数运行的时候自动生成的一个内部对象，只能在函数内部使用，this总指向调用他的对象。并且，this关键字<strong>一旦确定，不可更改。</strong>  </p></blockquote><h3 id="绑定规则和优先级"><a href="#绑定规则和优先级" class="headerlink" title="绑定规则和优先级"></a>绑定规则和优先级</h3><ul><li>默认绑定</li><li>隐式绑定</li><li>显示绑定</li><li>new绑定<blockquote><p>new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定</p></blockquote></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><blockquote><p>与传统函数不同，箭头函数中的this关键字<strong>指向该箭头函数被定义的对象</strong>。</p></blockquote></li><li><h2 id="Javascript中执行上下文和执行栈是什么？"><a href="#Javascript中执行上下文和执行栈是什么？" class="headerlink" title="Javascript中执行上下文和执行栈是什么？"></a>Javascript中执行上下文和执行栈是什么？</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote><p>执行上下文是一种对Javascript的代码执行环境的一种抽象概念，即只要有Javascript代码则会有执行上下文。  </p></blockquote><p><strong>执行上下文的类别</strong></p><ul><li>全局执行上下文：变量在全局内，只有一个全局执行上下文，浏览器的全局对象是window。</li><li>函数执行上下文：可以有无数个，当函数被调用执行的时候，就会创建一个对应的函数执行上下文。</li><li>Eval函数执行上下文：运行在eval函数中的代码，使用频率很低。</li></ul><p>执行上下文的生命周期：</p><pre><code class="highlight mermaid">graph LR  创建阶段--&gt;执行阶段--&gt;回收阶段</code></pre><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><blockquote><p>执行栈又称调用栈，它拥有<strong>后进先出</strong>的结构，用于存储所有的执行上下文。<br>当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中，后续每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中，引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文。</p></blockquote></li><li><h2 id="谈谈typeof和instanceof的区别"><a href="#谈谈typeof和instanceof的区别" class="headerlink" title="谈谈typeof和instanceof的区别"></a>谈谈typeof和instanceof的区别</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>typeof返回的是一个变量的基本类型。</li><li>typeof可以返回除(Null)外的基本类型，除(Function)外的引用类型。</li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul><li>instanceof返回的是布尔值。</li><li>instanceof可以准确判断变量的引用类型，但不可以判断变量的基本类型。</li></ul></li><li><h2 id="说说new操作符具体做了什么？"><a href="#说说new操作符具体做了什么？" class="headerlink" title="说说new操作符具体做了什么？"></a>说说new操作符具体做了什么？</h2><ul><li>创建一个新的对象。</li><li>把新的对象的_proto_指向原函数的构造函数。</li><li>将构造函数内的this指向到新对象上。</li><li>检查构造函数返回值。</li></ul><p>new操作符具体流程：</p><pre><code class="highlight mermaid">graph LR  新建对象--&gt;_proto_绑定--&gt;this绑定--&gt;检查返回值</code></pre></li><li><h2 id="说说Javascript中的事件模型"><a href="#说说Javascript中的事件模型" class="headerlink" title="说说Javascript中的事件模型"></a>说说Javascript中的事件模型</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><blockquote><p>在HTML文档或浏览器中发生的一系列交互操作，就称为事件。</p></blockquote><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><blockquote><p>由于DOM是一个树结构，因此在出现父子节点绑定事件，触发子节点的时候会引起顺序问题，由此有事件流之概念。  </p></blockquote><p>事件流有三个阶段：</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>事件模型分为三种：</p><ul><li>原始事件模型</li><li>标准事件模型</li><li>IE事件模型</li></ul><p><strong>原始事件模型</strong></p><blockquote><p>没有事件冒泡阶段</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;func()&quot;</span>&gt; <span class="comment">//此处的onclick绑定事件就是原始事件绑定</span></span><br></pre></td></tr></table></figure><p><strong>标准事件模型</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line"><span class="title function_">addEventListener</span>(eventType, handler, useCapture)</span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="title function_">removeEventListener</span>(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p><strong>IE事件模型</strong></p><blockquote><p>没有事件冒泡阶段</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line"><span class="title function_">attachEvent</span>(eventType, handler)</span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="title function_">detachEvent</span>(eventType, handler)</span><br></pre></td></tr></table></figure></li><li><h2 id="谈谈什么是事件代理？"><a href="#谈谈什么是事件代理？" class="headerlink" title="谈谈什么是事件代理？"></a>谈谈什么是事件代理？</h2><blockquote><p>事件代理就是指<strong>把事件委托在目标元素的外层元素上，当触发目标元素时，通过事件冒泡机制触发到它的外层绑定元素上，执行相应函数。</strong>  </p></blockquote><p><strong>整体有两大优点</strong>：</p><ul><li>减少内存使用。</li><li>动态绑定，避开重复工作。</li></ul></li><li><h2 id="ajax原理是什么？"><a href="#ajax原理是什么？" class="headerlink" title="ajax原理是什么？"></a>ajax原理是什么？</h2><ul><li>创建核心XmlHttpRequest(Xhr)对象。</li><li>通过Xhr对象的open方法，与服务器连接。</li><li>构造请求所需要的数据内容，通过Xhr的send方法发送给服务端。</li><li>通过Xhr对象提供的onreadystagechange监听服务端变化。</li><li>接收并处理服务端返回的结果数据。</li><li>将处理结果用javascript操作DOM实现更新。</li></ul><pre><code class="highlight mermaid">graph LR    创建Xhr对象--&gt;|open方法|连接服务器--&gt;|send方法|发送请求--&gt;|onreadystagechange|监听变化--&gt;接收并处理结果--&gt;|操作DOM|更新页面</code></pre></li><li><h2 id="谈谈bind-apply和call三者的区别"><a href="#谈谈bind-apply和call三者的区别" class="headerlink" title="谈谈bind,apply和call三者的区别"></a>谈谈bind,apply和call三者的区别</h2><p><strong>共同点</strong></p><ul><li>目的都是修改this关键字的指向。</li><li>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。  </li><li></li></ul><p><strong>不同点</strong></p><ul><li>apply和call是单次传参，bind可多次传参。</li><li>apply的参数为数组，call的参数为参数列表.</li><li>bind返回绑定this参数后的函数，apply和call立即执行函数。</li></ul></li><li><h2 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h2><blockquote><p>同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环。  </p></blockquote><p><strong>任务分为</strong>：</p><ul><li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行。</li><li>异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等<ul><li>微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</li><li>宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。</li></ul></li></ul></li><li><h2 id="说说Javascript中常见的内存泄露情况"><a href="#说说Javascript中常见的内存泄露情况" class="headerlink" title="说说Javascript中常见的内存泄露情况"></a>说说Javascript中常见的内存泄露情况</h2><ul><li>意外的全局变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  wrong = <span class="number">1</span> <span class="comment">// 变量没有在任何作用域有定义，会在全局作用域中隐式定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">wrong</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func2</span>() <span class="comment">//此时函数内this指向window，又会隐式生成一个全局变量</span></span><br></pre></td></tr></table></figure></li><li>闭包的私有变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcOutside</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;......&#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">funcInside</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// 没有清理对私有变量的引用</span></span><br><span class="line">    obj = <span class="literal">null</span> <span class="comment">// 需要这样正确清理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>未正确释放的DOM引用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refA = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;refA&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(refA)</span><br><span class="line"><span class="comment">//需要清理</span></span><br><span class="line">refA = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li><li>计时器中的引用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = <span class="title function_">getData</span>();</span><br><span class="line"><span class="title function_">setInteral</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;node&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">    <span class="comment">//外部引用</span></span><br><span class="line">    node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><h2 id="谈谈Javascript中的几种本地存储"><a href="#谈谈Javascript中的几种本地存储" class="headerlink" title="谈谈Javascript中的几种本地存储"></a>谈谈Javascript中的几种本地存储</h2><ul><li>cookie</li><li>sessionStorage</li><li>localStorage</li></ul><p><strong>不同点</strong></p><ul><li>存储大小：cookie只能存储最多<strong>4K</strong>大小的文本数据，而后两者可以存储<strong>5MB以上</strong>的数据。</li><li>生命周期：cookie的生命周期取决于<strong>设置的过期时间</strong>，sessionStorage是在<strong>当前窗口关闭的时候会自动删除</strong>，localStorage<strong>存储持久数据</strong>，关闭浏览器不会丢失数据。</li><li>交互方法：cookie的数据会自动传输给服务器，服务器也可以写cookie给客户端。localStorage和sessionStorage只能在本地存储。</li></ul></li><li><h2 id="谈谈Javascript中数字精度丢失的问题"><a href="#谈谈Javascript中数字精度丢失的问题" class="headerlink" title="谈谈Javascript中数字精度丢失的问题"></a>谈谈Javascript中数字精度丢失的问题</h2><blockquote><p>简单的说，就是十进制数字需要先转为二进制数，然后再进行计算后转回十进制数得到结果。其中，进制的转换会由于<strong>位数限制、某些数转二进制出现无限循环</strong>造成数值转换后会出现偏差，导致结果不符合直觉。</p></blockquote></li><li><h2 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><blockquote><p>防抖就是指在n秒后再执行事件，如果在n秒内重复触发，则重新计时。</p></blockquote><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><blockquote><p>节流就是指在n秒内只执行一次事件，如果在n秒内重复触发，只有一次生效。</p></blockquote></li></ul><h1 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h1>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS八股文</title>
      <link href="/2025/05/28/interview.data-2/"/>
      <url>/2025/05/28/interview.data-2/</url>
      
        <content type="html"><![CDATA[<h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><ul><li><h2 id="说说你对盒子模型的理解"><a href="#说说你对盒子模型的理解" class="headerlink" title="说说你对盒子模型的理解"></a>说说你对盒子模型的理解</h2><p><strong>盒子模型的图例</strong><br><img src="https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/Styling_basics/Box_model/box-model.png" alt="盒子模型" title="盒子模型图例"><br>盒子模型主要分为两种：</p><ul><li>标准盒子模型：content的width&#x2F;height不包含padding&#x2F;border</li><li>怪异盒子模型：content的width&#x2F;height包含padding&#x2F;border</li></ul></li><li><h2 id="CSS选择器有哪些？优先级如何？"><a href="#CSS选择器有哪些？优先级如何？" class="headerlink" title="CSS选择器有哪些？优先级如何？"></a>CSS选择器有哪些？优先级如何？</h2><ul><li><strong>常用的选择器有：</strong><ul><li>ID选择器 #a</li><li>类选择器 .a</li><li>标签选择器 div</li><li>子选择器 #a b</li><li>后代选择器 a&gt;a_1</li><li>相邻同胞选择器 .a+.b</li><li>群组选择器 div,p</li></ul></li><li><strong>不常用的选择器有：</strong><ul><li>伪类选择器</li><li>伪元素选择器</li><li>属性选择器</li><li>层次选择器</li></ul></li><li><strong>优先级:</strong> 内联&gt;ID&gt;类&gt;…</li></ul></li><li><h2 id="谈谈你对Flex布局的理解"><a href="#谈谈你对Flex布局的理解" class="headerlink" title="谈谈你对Flex布局的理解"></a>谈谈你对Flex布局的理解</h2><blockquote><p>Flex布局，即弹性盒子布局，容器内部是有一条主轴和与之形成直角的交叉轴构成，容器内元素默认沿主轴方向排列，其方向由flex-direction决定。  </p></blockquote><p><strong>Flex布局图例</strong><br><img src="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox/basics1.svg" alt="flex布局" title="flex布局图例"><br><img src="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox/basics3.svg" alt="flex布局" title="flex布局图例"></p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul></li><li><h2 id="谈谈你对BFC的理解"><a href="#谈谈你对BFC的理解" class="headerlink" title="谈谈你对BFC的理解"></a>谈谈你对BFC的理解</h2><p> BFC（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则：</p><ul><li>内部的盒子会在垂直方向上一个接一个的放置</li><li>对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。</li><li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 <blockquote><p>BFC目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素。</p></blockquote></li></ul><p> <strong>触发条件</strong></p><ul><li>根元素，即HTML元素</li><li>浮动元素：float值为left、right</li><li>overflow值不为 visible，为 auto、scroll、hidden</li><li>display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li><li>position的值为absolute或fixed</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测绘程序设计大赛心得</title>
      <link href="/2024/05/01/competition.gis-1/"/>
      <url>/2024/05/01/competition.gis-1/</url>
      
        <content type="html"><![CDATA[<h1 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a>经验分享</h1><ul><li><h2 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h2><blockquote><p>测绘程序设计比赛由于是比较新的比赛，比赛难度实际不大，主要就是考察<strong>文件的读写、把书面公式转为逻辑代码</strong>的能力。</p></blockquote></li><li><h2 id="赛题分析"><a href="#赛题分析" class="headerlink" title="赛题分析"></a>赛题分析</h2></li><li><h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2></li></ul>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIS </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
